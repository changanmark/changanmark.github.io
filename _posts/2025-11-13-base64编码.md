---
title: base64编码
date: 2025-11-13 00:00:00 +0800 # YYYY-MM-DD HH:MM:SS +/-TTTT 2022-01-01 13:14:15 +0800 只写日期也行；不写秒也行；这样也行 2022-03-09T00:55:42+08:00
categories: ["编程"]
tags: ["编解码"]     # TAG names should always be lowercase

media_subpath: "/assets/img/posts/2025-11-13-base64编码"

math: true
mermaid: true
---

## base64的功能和用途
base64 是一种把二进制数据编码成可打印字符的编码算法，base64 编码时输入是二进制数据，输出是一个可见字符串，解码则相反。

如果想在 html 中写一个图片，可以将图片编码成 base64 字符串，将字符串写在 html 的 img 标签中。

如果想在 json 或者 xml 中传输图片或者音频数据，base64 可以把图片或者音频编码成一个字符串存放在 json 或者 xml 中。

## 为什么需要 base64 编码而不用 UTF-8 编码？
因为有的二进制数据对应到 UTF-8 编码表中不存在，例如`11111111`。或者是一个不可打印（不可见）字符，例如`00100000`空格。因此二进制数据想要写在文本文件中，不能使用 UTF-8 码表编码。

## base64编码算法
png 图片格式的 Magic Number二进制如下：`10001001`,`01010000`,`01001110`,`01000111`

如果图片仅有以上数据，那么将上述 png 图片转换为 base64 的过程如下：

![alt text](image-1.png)

1. 将二进制数据由 8 个一组变为 6 个一组重新分组，最后一组不足 6 个的后面补 0，补够一组。
2. 按照 base64 编码表将 base64 每个分组的数据转换为对应字符，拼接成一个字符串。
3. 如果末尾补了2个0，则添加一个等号，如果末尾补了4个0 则添加两个等号。

## base64码表
![base64 码表](image.png)

## base64算法的空间浪费
由于将原来 8 个字节的数据按照 6 个一组重新排列，并且这 6 个二进制按照 base64 编码表变成一个字符后，对应到 UTF-8 编码表占用 1 个字节。这相当于原来能存储 8 位二进制数据的空间现在只能存储 6 位的二进制数据，因此相当于浪费掉大于等于原来 1/4 的空间。

大于是因为有可能还有补齐的 0 和等号，补齐的 0 和等号最大浪费不到 3 个字节，结尾浪费最大的情况是补两个二进制 0 和 两个等号，可以忽略不计。

## Java实现
```java

public class MyBase64Encode {
    // base64码表
    private static final char[] BASE64_CHARS =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".toCharArray();

    public static void main(String[] args) {
        int[] data = {0b10001001, 0b01010000, 0b01001110, 0b01000111};

        String encodeStr = encode(data);
        System.out.println(encodeStr);
    }

    private static String encode(int[] data) {
        if (data == null || data.length == 0) return "";

        int len = data.length;
        // 3 bytes -> 4 chars, 所以最终长度 = ceil(len/3)*4
        // ceil(len/3) = (len+2)/3
        int outLen = ((len + 2) / 3) * 4;
        StringBuilder sb = new StringBuilder(outLen);

        int i = 0;
        while (i + 2 < len) {
            // 取三字节，合并为 24 位
            int b0 = data[i++] & 0xFF;
            int b1 = data[i++] & 0xFF;
            int b2 = data[i++] & 0xFF;
            int combined = (b0 << 16) | (b1 << 8) | b2;

            // 拆成 4 个 6-bit 单元
            sb.append(BASE64_CHARS[(combined >>> 18) & 0x3F]);
            sb.append(BASE64_CHARS[(combined >>> 12) & 0x3F]);
            sb.append(BASE64_CHARS[(combined >>> 6)  & 0x3F]);
            sb.append(BASE64_CHARS[combined & 0x3F]);
        }

        int remaining = len - i;
        if (remaining == 1) {
            int b0 = data[i] & 0xFF;
            int combined = b0 << 16;
            sb.append(BASE64_CHARS[(combined >>> 18) & 0x3F]);
            sb.append(BASE64_CHARS[(combined >>> 12) & 0x3F]);
            sb.append("=="); // 两个填充
        } else if (remaining == 2) {
            int b0 = data[i++] & 0xFF;
            int b1 = data[i] & 0xFF;
            int combined = (b0 << 16) | (b1 << 8);
            sb.append(BASE64_CHARS[(combined >>> 18) & 0x3F]);
            sb.append(BASE64_CHARS[(combined >>> 12) & 0x3F]);
            sb.append(BASE64_CHARS[(combined >>> 6) & 0x3F]);
            sb.append('=');
        }

        return sb.toString();
    }
}
```
---
title: CSS堆叠上下文
date: 2025-10-28 00:00:00 +0800 # YYYY-MM-DD HH:MM:SS +/-TTTT 2022-01-01 13:14:15 +0800 只写日期也行；不写秒也行；这样也行 2022-03-09T00:55:42+08:00
categories: ["编程"]
tags: ["CSS"]     # TAG names should always be lowercase

media_subpath: "/assets/img/posts/2025-10-28-CSS堆叠上下文"

math: true
mermaid: true
---
## DOM元素的覆盖问题
> 问题：下面有两段代码，box1的阴影为什么被遮挡了？怎么解决？

代码1:
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <style>
        html, body {
            height: 100%;
            width: 100%;
        }
        #container {
            display: inline-flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
        }

        #box1 {
            width: 100%;
            flex:1;
            background-color: red;
            box-shadow: 0 10px 5px red;
        }

        #box2 {
            width: 100%;
            flex: 1;
            background-color: blue;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="box1"></div>
        <div id="box2"></div>
    </div>
</body>
</html>
```

代码2: box1的z-index大于box2的z-index，但是box2遮挡了box1
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <style>
        html, body {
            height: 100%;
            width: 100%;
        }
        #container {
            display: inline-flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
        }

        #box1 {
            width: 100%;
            height: 100%;
            background-color: red;
            box-shadow: 0 10px 5px red;
            z-index: 100;
        }

        #box2 {
            width: 100%;
            height: 100%;
            background-color: blue;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div id="container">
        <div style="flex: 1;">
            <div id="box1"></div>
        </div>
        <div style="flex: 1">
            <div id="box2"></div>
        </div>
    </div>
</body>
</html>
```
![alt text](image-9.png)
## 平民时代的DOM元素
没有CSS的年代，DOM元素都是平民，人人平等。默认情况下，块元素独占一行，行内元素紧接其后依次排列在window窗口中，根本不存在谁覆盖谁的问题。

## CSS给DOM元素带来等级制度
CSS让原本流式排列的DOM元素产生了等级（stacking-level）。从此DOM元素像广告牌上贴广告一样按等级排列，等级高的DOM元素贴在上层，等级低的元素被遮挡。

![alt text](image.png)

## 等级DOM元素的覆盖规则
1. 高等级的DOM覆盖低等级的DOM
2. 等级一样，后来的DOM覆盖先来的DOM

## CSS赋予DOM的等级制度细节
CSS赋予DOM的等级制度有两条：
1. 堆叠上下文（stacking-context）
2. 堆叠顺序（stacking-order）

堆叠上下文是大的等级，每个堆叠上下文内部又有自己的等级制度-堆叠顺序。

还是以广告牌举例：
堆叠上下文相当于广告牌级别，如果想通过堆叠上下文区分等级高低，那就是广告牌上再来一层广告牌，谁的广告牌多，谁的等级就高。

堆叠顺序相当于每个广告牌上的小广告，在一块广告牌内部，如果想通过堆叠顺序区分等级高低，那就提升自己在众多小广告中的顺序，谁的顺序大，谁的等级就高。

## HTML中如何让自己再来一块广告牌？
以下方式都可以生成堆叠上下文，如果想变高，那就多套几层：

1. 文档的根元素（<html>）。
2. position具有值absolute或relative以及z-index除auto值之外的值的元素。
3. position具有值fixed或sticky的元素。
4. container-type具有值size或集合的元素inline-size。
5. 具有除z-index:auto之外的值的flex元素。
6. 具有除z-index:auto之外的值的gride元素。
7. opacity值小于1的元素。
8. mix-blend-mode具有除normal之外的值的元素。
9. 具有以下任一属性且值为none以外的值的元素：
- transform
- scale
- rotate
- translate
- filter
- backdrop-filter
- perspective
- clip-path
- mask/mask-image/mask-border
10. isolation值为isolate的元素。
11. 元素的will-change值指定了将在非初始值上创建堆叠上下文的任何属性。
12. contain值为layout或paint的元素，或包含其中任一值的复合值（即 contain: strict）contain: content。
13. 放置在顶层的元素及其对应的::backdrop。示例包括全屏和弹出元素。
14. 具有堆叠上下文创建属性（例如opacity）的元素使用@keyframes进行动画处理，并将animation-fill-mode设置为forwards。

## HTML中如何让自己众多小广告中略胜一筹？
如下图，越外层的元素堆叠顺序越高
![alt text](image-3.png)

实际测试结果和上图有出入，实际测试结果如下：
1. z-index<0
2. backgound
3. float
4. block
5. inline
6. z-index = 0 和 z-index=auto
7. z-index > 0

测试代码如下：
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>Stacking Order 实验</title>
<style>
  body {
    background: #eee;
  }
  /* 1️⃣ 背景层 */
  #container {
    position: relative;
    width: 800px;
    height: 600px;
    border: 5px solid #333;
    margin: 50px auto;
    background: #a47ab9;
  }

  /* 2️⃣ z-index < 0 的定位元素 */
  .neg-index {
    position: absolute;
    top: 0px;
    left: 0px;
    width: 300px;
    height: 300px;
    background: #d84e3d;
    z-index: -1;
  }

  /* 3️⃣ 块级元素 */
  .block-box {
    display: block;
    position: absolute;
    top: 50px;
    left: 50px;
    width: 300px;
    height: 300px;
    background-color: #597fbf;
  }

  /* 4️⃣ 非定位块级元素 + 浮动 */
  .float-block {
    float: left;
    width: 300px;
    height: 500px;
    margin-top: 100px;
    margin-left: 100px;
    background: #de9a48;
  }

  /* 5️⃣ 非定位行内元素 */
  .inline {
    display: inline;
    background: #aac358;
    font-size: 50px;
    color: white;
    position: relative;
    top: 150px;
    left: -300px
  }

  /* 6️⃣ z-index: auto（未指定）定位元素 */
  .auto-index {
    position: absolute;
    top: 200px;
    left: 200px;
    width: 300px;
    height: 300px;
    background: #70c1ad;
  }

  /* 7️⃣ z-index >= 0 的定位元素 */
  .pos-index {
    position: absolute;
    top: 250px;
    left: 250px;
    width: 300px;
    height: 300px;
    background: #597fbf;
    z-index: 10;
  }
</style>
</head>
<body>
  <div id="container">1 背景层
    <div class="neg-index">2 z-index&lt;0</div>
    <div class="block-box">3 块元素</div>
    <div class="float-block">4 块级浮动</div>
    <div class="inline">5 行内元素=======</div>
    <div class="auto-index">6 z-index:auto</div>
    <div class="pos-index">7 z-index≥0</div>
  </div>
</body>
</html>
```
![alt text](image-6.png)

回到最初的问题：

第一段代码被遮挡是因为box1和box2等级一样，后来的DOM box2遮挡了box1的阴影。

第二段代码被遮挡是因为box1虽然z-index较大，但是box1和box2是包含在两个独立的堆叠上下文中，box1的堆叠顺序(z-index)只能跟其堆叠上下文内部的元素比较，因此box2盖住box1是因为他们两个堆叠上下文是同级的，并且box2的堆叠上下文DOM在box1的堆叠上下文DOM之后，因此box1的阴影也被遮挡了。